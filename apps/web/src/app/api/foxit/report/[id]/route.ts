import { NextRequest, NextResponse } from "next/server";

const FOXIT_CLIENT_ID = process.env.FOXIT_CLIENT_ID || "";
const FOXIT_CLIENT_SECRET = process.env.FOXIT_CLIENT_SECRET || "";
const FOXIT_BASE_URL = "https://na1.fusion.foxit.com";

function escapeXml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

function buildMergedDocxBase64(data: {
  incident_id: string;
  title: string;
  status: string;
  created_at: string;
  root_cause: string;
  fix_steps: string;
  confidence: string;
}): string {
  const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    <w:p>
      <w:pPr><w:jc w:val="center"/></w:pPr>
      <w:r><w:rPr><w:b/><w:sz w:val="32"/></w:rPr><w:t>INCIDENT REPORT</w:t></w:r>
    </w:p>
    <w:p><w:r><w:t xml:space="preserve">Incident ID: ${escapeXml(data.incident_id)}</w:t></w:r></w:p>
    <w:p><w:r><w:t xml:space="preserve">Title: ${escapeXml(data.title)}</w:t></w:r></w:p>
    <w:p><w:r><w:t xml:space="preserve">Status: ${escapeXml(data.status)}</w:t></w:r></w:p>
    <w:p><w:r><w:t xml:space="preserve">Date: ${escapeXml(data.created_at)}</w:t></w:r></w:p>
    <w:p><w:r><w:t xml:space="preserve">Root Cause: ${escapeXml(data.root_cause)}</w:t></w:r></w:p>
    <w:p><w:r><w:t xml:space="preserve">Fix Steps: ${escapeXml(data.fix_steps)}</w:t></w:r></w:p>
    <w:p><w:r><w:t xml:space="preserve">Confidence: ${escapeXml(data.confidence)}</w:t></w:r></w:p>
    <w:p><w:r><w:t>Generated by Autonomous Incident Agent (AIA)</w:t></w:r></w:p>
    <w:sectPr><w:pgSz w:w="12240" w:h="15840"/></w:sectPr>
  </w:body>
</w:document>`;

  const contentTypesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>`;

  const relsXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`;

  const wordRelsXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>`;

  const zipBuffer = createZipBytes({
    "[Content_Types].xml": Buffer.from(contentTypesXml, "utf8"),
    "_rels/.rels": Buffer.from(relsXml, "utf8"),
    "word/document.xml": Buffer.from(documentXml, "utf8"),
    "word/_rels/document.xml.rels": Buffer.from(wordRelsXml, "utf8"),
  });

  return zipBuffer.toString("base64");
}

function createZipBytes(files: Record<string, Buffer>): Buffer {
  const entries: Buffer[] = [];
  const centralDir: Buffer[] = [];
  let offset = 0;

  for (const [filename, content] of Object.entries(files)) {
    const nameBytes = Buffer.from(filename, "utf8");
    const crc = crc32(content);

    const localHeader = Buffer.alloc(30 + nameBytes.length);
    localHeader.writeUInt32LE(0x04034b50, 0);
    localHeader.writeUInt16LE(20, 4);
    localHeader.writeUInt16LE(0, 6);
    localHeader.writeUInt16LE(0, 8);
    localHeader.writeUInt16LE(0, 10);
    localHeader.writeUInt16LE(0, 12);
    localHeader.writeUInt32LE(crc, 14);
    localHeader.writeUInt32LE(content.length, 18);
    localHeader.writeUInt32LE(content.length, 22);
    localHeader.writeUInt16LE(nameBytes.length, 26);
    localHeader.writeUInt16LE(0, 28);
    nameBytes.copy(localHeader, 30);

    entries.push(localHeader);
    entries.push(content);

    const cdEntry = Buffer.alloc(46 + nameBytes.length);
    cdEntry.writeUInt32LE(0x02014b50, 0);
    cdEntry.writeUInt16LE(20, 4);
    cdEntry.writeUInt16LE(20, 6);
    cdEntry.writeUInt16LE(0, 8);
    cdEntry.writeUInt16LE(0, 10);
    cdEntry.writeUInt16LE(0, 12);
    cdEntry.writeUInt16LE(0, 14);
    cdEntry.writeUInt32LE(crc, 16);
    cdEntry.writeUInt32LE(content.length, 20);
    cdEntry.writeUInt32LE(content.length, 24);
    cdEntry.writeUInt16LE(nameBytes.length, 28);
    cdEntry.writeUInt16LE(0, 30);
    cdEntry.writeUInt16LE(0, 32);
    cdEntry.writeUInt16LE(0, 34);
    cdEntry.writeUInt16LE(0, 36);
    cdEntry.writeUInt32LE(0, 38);
    cdEntry.writeUInt32LE(offset, 42);
    nameBytes.copy(cdEntry, 46);

    centralDir.push(cdEntry);
    offset += localHeader.length + content.length;
  }

  const centralDirBuf = Buffer.concat(centralDir);
  const eocd = Buffer.alloc(22);
  eocd.writeUInt32LE(0x06054b50, 0);
  eocd.writeUInt16LE(0, 4);
  eocd.writeUInt16LE(0, 6);
  eocd.writeUInt16LE(centralDir.length, 8);
  eocd.writeUInt16LE(centralDir.length, 10);
  eocd.writeUInt32LE(centralDirBuf.length, 12);
  eocd.writeUInt32LE(offset, 16);
  eocd.writeUInt16LE(0, 20);

  return Buffer.concat([...entries, centralDirBuf, eocd]);
}

function crc32(buf: Buffer): number {
  const table = makeCrcTable();
  let crc = 0xffffffff;
  for (let i = 0; i < buf.length; i++) {
    crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xff];
  }
  return (crc ^ 0xffffffff) >>> 0;
}

let _crcTable: number[] | null = null;
function makeCrcTable(): number[] {
  if (_crcTable) return _crcTable;
  _crcTable = [];
  for (let n = 0; n < 256; n++) {
    let c = n;
    for (let k = 0; k < 8; k++) {
      c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
    }
    _crcTable[n] = c;
  }
  return _crcTable;
}

async function foxitGeneratePdf(incident: any): Promise<ArrayBuffer> {
  const mergedDocxBase64 = buildMergedDocxBase64({
    incident_id: String(incident.id || "N/A"),
    title: String(incident.title || "Untitled Incident"),
    status: String(incident.status || "unknown"),
    created_at: incident.created_at
      ? new Date(incident.created_at).toLocaleString()
      : new Date().toLocaleString(),
    root_cause: String(
      incident.autopsy?.root_cause_text ||
        incident.root_cause ||
        "Analyzing...",
    ),
    fix_steps: String(
      incident.autopsy?.manual_steps?.join("; ") || "See full report",
    ),
    confidence: incident.autopsy?.confidence
      ? `${(incident.autopsy.confidence * 100).toFixed(0)}%`
      : "N/A",
  });

  const generateRes = await fetch(
    `${FOXIT_BASE_URL}/document-generation/api/GenerateDocumentBase64`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        client_id: FOXIT_CLIENT_ID,
        client_secret: FOXIT_CLIENT_SECRET,
      },
      body: JSON.stringify({
        base64FileString: mergedDocxBase64,
        outputFormat: "pdf",
      }),
    },
  );

  if (!generateRes.ok) {
    const err = await generateRes.text();
    throw new Error(
      `Foxit Document Generation failed: ${generateRes.status} - ${err}`,
    );
  }

  const generateData = await generateRes.json();
  const pdfBase64: string =
    generateData.data?.base64FileString ||
    generateData.base64FileString ||
    generateData.data;

  if (!pdfBase64) {
    throw new Error(
      `Foxit returned no PDF data. Response: ${JSON.stringify(generateData).slice(0, 200)}`,
    );
  }

  return Buffer.from(pdfBase64, "base64").buffer;
}

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  const { id } = await params;

  if (!FOXIT_CLIENT_ID || !FOXIT_CLIENT_SECRET) {
    return NextResponse.json(
      {
        error: "Foxit credentials not configured",
        setup:
          "Add FOXIT_CLIENT_ID and FOXIT_CLIENT_SECRET to environment variables",
        signup: "https://developer-api.foxit.com/",
      },
      { status: 503 },
    );
  }

  try {
    const STATE_URL = process.env.STATE_SERVICE_URL || "http://localhost:3003";
    let incident: any = { id, title: `Incident ${id}`, status: "unknown" };

    try {
      const stateRes = await fetch(`${STATE_URL}/incidents/${id}`);
      if (stateRes.ok) {
        incident = await stateRes.json();
      }
    } catch {}

    const pdfBuffer = await foxitGeneratePdf(incident);

    return new NextResponse(pdfBuffer, {
      status: 200,
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="incident-${id}-report.pdf"`,
        "Content-Length": pdfBuffer.byteLength.toString(),
        "X-Generated-By": "Foxit Document Generation API",
      },
    });
  } catch (error: any) {
    console.error("[Foxit] PDF generation error:", error);
    return NextResponse.json(
      { error: error.message, service: "foxit-integration" },
      { status: 500 },
    );
  }
}
